#!/usr/bin/env python
##############################################################################
# Copyright (c) CERN, 2014.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at #
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS
# OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
##############################################################################
#
# NAME :        ugrconfig_from_AGIS.py
#
# DESCRIPTION : Extract info that is used to configure an HTTP federation that uses the Dynamic Federations.
#
# AUTHORS :     Ivan.Calvet@cern.ch
#
##############################################################################

import os
import sys
import argparse
import urllib2, simplejson
from   subprocess import Popen, PIPE

def main():
    # Argument parsing
    parser = argparse.ArgumentParser(description='Extract info that is used to configure an HTTP federation that uses the Dynamic Federations.')
    parser.add_argument('-P', '--profil', choices=['NO_CHECK', 'grid'], help='choose between the "grid" profil (which use the X509_USER_PROXY environment variable as proxy) and the "NO_CHECK" profil to not test all the URLs.')
    parser.add_argument('-E', '--cert', metavar='CRED_PATH', help='client Certificate in PEM format')
    parser.add_argument('--key', metavar='KEY_PATH', help='private key in PEM format')
    parser.add_argument('--capath', metavar='CA_PATH', help='add an additional certificate authority directory')
    parser.add_argument('-k', '--insecure', action="store_true", help='disable SSL credential checks')
    parser.add_argument('-e', '--exclude', metavar='KEYWORD', nargs='*', help='exclude the paths containing these keywords (spaces separated).')
    parser.add_argument('-t', '--threads', metavar='NUMBER', type=int, default="5", help='specify the number of threads at each entry (5 by default).')
    parser.add_argument('-o', '--output', metavar='FILENAME', default="ugr-endpoints.conf", help='change the filename of the output (ugr-endpoints.conf by default).')
    parser.add_argument('-v', '--version', action='version', version='%(prog)s 1.0')
    args = parser.parse_args()

    if not (args.profil or args.cert):
        parser.print_help()
        sys.exit(1)
    if args.profil != 'NO_CHECK':
        if args.profil == 'grid':
            if not 'X509_USER_PROXY' in os.environ:
                sys.exit("Error: The environment variable X509_USER_PROXY is not defined.")
        else:
            os.environ['X509_USER_PROXY'] = args.cert
        if not os.path.exists(os.environ['X509_USER_PROXY']):
            sys.exit("Error: Path of the certificate incorrect.")

    # AGIS request
    req = urllib2.Request("http://atlas-agis-api.cern.ch/request/service/query/get_se_services/?json&flavour=HTTP", None)
    opener = urllib2.build_opener()
    f = opener.open(req)
    res = simplejson.load(f)

    output = []
    nb = 0
    for s in res:
        nb += 1
        print ">>> Entry %s / %s:" % (nb, len(res))
        protocols = []
        if 'r' in s["aprotocols"]:
            for p in s["aprotocols"]['r']:
                # Exclusion of some keywords
                if args.exclude and [val for val in args.exclude if val in p[2]]:
                    continue
                # We consider only the paths that finish with "/rucio/" and we remove it
                if p[2].endswith("/rucio/"):
                    protocols.append(p[2][:-6])
        prefix = os.path.commonprefix(protocols)
        prefix = prefix[:prefix.rfind("/")]
        protocols = [p[len(prefix):] for p in protocols]
        if protocols:
            impl = s["impl"]
            if not s["impl"]:
                impl = "???"
            site = s["rc_site"]
            url = s["endpoint"] + prefix
            if args.profil != "NO_CHECK":
                SSL_Error = False
                for p in list(protocols):
                    request_url = url + p
                    code, stdout, stderr = request(request_url,args)
                    print "Test of %s" % request_url
                    if code:
                        print "-> FAILED: %s\n" % stderr.rstrip()
                        protocols.remove(p)
                        if 'Neon error: SSL handshake failed' in stderr:
                            SSL_Error = True
                    else:
                        print "-> OK\n"
                if SSL_Error:
                    protocols = []
            if protocols:
                out = """###########
## Talk to a %s instance in %s
##
glb.locplugin[]: /usr/local/lib64/ugr/libugrlocplugin_davrucio.so %s %s %s
locplugin.%s.pfxmultiply:%s""" % (impl, site, site, args.threads, url, site, ' '.join(protocols))
                output.append(out)
        else:
            print "-> No path to test\n"
        print
    file = open(args.output, 'w')
    file.write("\n\n".join(output))
    file.close()
    sys.exit(0)

def request(url, args):
    """ Execute a request defined by the action to test an url"""
    if args.key:
        command = ['davix-ls', '-E', args.cert, '--key', args.key]
    else:
        command = ['davix-ls', '-P','grid']
    if args.insecure:
        command.append('-k')
    if args.capath:
        command.extend(["--capath", args.capath])
    command.append(url)
    try:
        process = Popen(command, stdout=PIPE, stderr=PIPE)
    except:
        sys.exit("Error: Please install davix to be able to check every URL.")
    code = process.wait()
    stdout, stderr = process.communicate()
    return (code, stdout, stderr)


if __name__ == "__main__":
    main()
